//
//  main.swift
//  cpptoswift
//
//  Created by Uli Kusterer on 18/10/15.
//  Copyright Â© 2015 Uli Kusterer. All rights reserved.
//

import Foundation


func lastPathComponent( str : String ) -> String
{
	let dfstr = NSString(string: str)
	let slashRange : NSRange? = dfstr.rangeOfString( "/", options: NSStringCompareOptions.BackwardsSearch, range: NSRange(location:0,length:dfstr.length), locale: nil )
	return dfstr.substringFromIndex( slashRange!.location + slashRange!.length )
}

func withoutPathExtension( str : String ) -> String
{
	let dfstr = NSString(string: str)
	let slashRange : NSRange? = dfstr.rangeOfString( ".", options: NSStringCompareOptions.BackwardsSearch, range: NSRange(location:0,length:dfstr.length), locale: nil )
	return dfstr.substringToIndex( slashRange!.location )
}
	

class cpptoswift
{
	let		sourceFile : String
	let		destinationFile : String
	var		destinationHeaderContents = ""
	var		destinationSourceContents = ""
	var		destinationSwiftContents = ""
	
	init( sourceFile srcFile : String, destinationFile dstFile : String )
	{
		sourceFile = srcFile
		destinationFile = dstFile
	}
	
	
	func cTypeToSwift( typeStr : String, inout isClass : Bool ) -> String
	{
		isClass = false;
		switch( typeStr )
		{
			case "short":
				return "Int16"
			case "int":
				return "Int32"
			case "long":
				return "Int64"
			case "long long":
				return "Int64"
			case "void":
				return "Void"
			case "double":
				return "Double"
			default:	// Unknown? Assume it's a class.
				isClass = true
				return typeStr.stringByTrimmingCharactersInSet( NSCharacterSet(charactersInString: "* \t\r\n") )
		}
	}
	
	func methodSignatureFromDeclaration( paramListStr : NSString ) -> [[String]]
	{
		var	paramsWithoutTypes : [[String]] = []
		var	paramsWithTypes = paramListStr.componentsSeparatedByString(",")
		for( var x = 0; x < paramsWithTypes.count; x++ )
		{
			let		parts = paramsWithTypes[x].stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()).componentsSeparatedByCharactersInSet( NSCharacterSet.whitespaceAndNewlineCharacterSet() )
			let	allButLast = parts[0..<parts.count-1]
			let paramType = NSArray(array:Array(allButLast)).componentsJoinedByString(" ")
			var isClass = false
			let swiftType = cTypeToSwift(paramType, isClass: &isClass)
			let varName = parts.last! as String
			paramsWithoutTypes.append( [ varName, paramType, swiftType, varName + (isClass ? ".cppinstance" : "") ] )
		}
		return paramsWithoutTypes
	}

	func callParamsFromDeclaration( paramListStr : NSString ) -> String
	{
		let params = methodSignatureFromDeclaration( paramListStr )
		
		let paramNames = params.map { (var curr) -> String in return curr[0] }
		
		return NSArray(array: paramNames).componentsJoinedByString(",")
	}
	
	func swiftCallParamsFromDeclaration( paramListStr : NSString ) -> String
	{
		let params = methodSignatureFromDeclaration( paramListStr )
		
		let paramNames = params.map { (var curr) -> String in return curr[3] }
		
		return NSArray(array: paramNames).componentsJoinedByString(",")
	}
	
	func swiftDeclaration( paramListStr : NSString ) -> String
	{
		let params = methodSignatureFromDeclaration( paramListStr )
		
		let paramNames = params.map { (var curr) -> String in return curr[0] + " : " + curr[2] }
		
		return NSArray(array: paramNames).componentsJoinedByString(",")
	}
	
	func parse() throws
	{
		let	shortenedDestinationFile = lastPathComponent( destinationFile )
		let	shortenedSourceFile = lastPathComponent( sourceFile )
	
		destinationHeaderContents = "// This file was auto-generated by cpptoswift.\n// Do not edit this file, edit the original source file \(sourceFile)\n\n#if __cplusplus\nextern \"C\"\n{\n#endif /* __cplusplus */\n\n"
		destinationSourceContents = "// This file was auto-generated by cpptoswift.\n// Do not edit this file, edit the original source file \(sourceFile)\n\n#include \"\(shortenedDestinationFile).h\"\n#include \"\(shortenedSourceFile)\"\n\n\n"
		destinationSwiftContents = "// This file was auto-generated by cpptoswift.\n// Do not edit this file, edit the original source file \(sourceFile)\n\n"
		
		let	fileContents = try NSString(contentsOfFile: sourceFile, encoding: NSUTF8StringEncoding)
		
		var	classNameStr = ""
		let	fileLength = fileContents.length;
		var	searchRange = NSRange(location: 0, length: fileLength)
		while( true )
		{
			var	foundClassRange : NSRange = fileContents.rangeOfString( "CP2SCLASS", options: NSStringCompareOptions(), range: searchRange )
			let	foundMethodRange : NSRange = fileContents.rangeOfString( "CP2SMETHOD", options: NSStringCompareOptions(), range: searchRange )
			let	foundInitRange : NSRange = fileContents.rangeOfString( "CP2SINIT", options: NSStringCompareOptions(), range: searchRange )
			let	foundGetterRange : NSRange = fileContents.rangeOfString( "CP2SGETTER", options: NSStringCompareOptions(), range: searchRange )
			let	foundSetterRange : NSRange = fileContents.rangeOfString( "CP2SSETTER", options: NSStringCompareOptions(), range: searchRange )
			if foundMethodRange.location == NSNotFound && foundInitRange.location == NSNotFound && foundClassRange.location == NSNotFound && foundGetterRange.location == NSNotFound && foundSetterRange.location == NSNotFound
			{
				break;
			}
			
			var	foundRange = (foundMethodRange.location < foundInitRange.location) ? foundMethodRange : foundInitRange
			if( foundRange.location > foundGetterRange.location )
			{
				foundRange = foundGetterRange
			}
			if( foundRange.location > foundSetterRange.location )
			{
				foundRange = foundSetterRange
			}
			let	isInit = foundInitRange.location == foundRange.location
			
			if( foundClassRange.location != NSNotFound && foundClassRange.location < foundRange.location )
			{
				var		classNameStartLocation : Int?
				var		classNameEndLocation : Int?
				
				for( var x = foundClassRange.location - 1; x > 0; x-- )
				{
					switch( fileContents.characterAtIndex(x) )
					{
						case 0x20, 0x09, 0x0d, 0x0a:
							if( classNameEndLocation != nil && classNameStartLocation == nil )
							{
								classNameStartLocation = x + 1
							}
						case 0x23:	// Hash sign? Prolly the preprocessor macros we use to hide our markers from C.
							x = -1;
							var classSearchRange : NSRange = searchRange
							classSearchRange.location = foundClassRange.location + foundClassRange.length
							classSearchRange.length = fileLength - classSearchRange.location
							
							// Try to find the next class name declaration:
							//	This is necessary as the defines to hide our tokens from the
							//	C++ compiler give us false positives, and may be immediately followed
							//	by another class declaration.
							foundClassRange = fileContents.rangeOfString( "CP2SCLASS", options: NSStringCompareOptions(), range: classSearchRange )
							if foundClassRange.location < foundRange.location
							{
								classNameStartLocation = nil;
								classNameEndLocation = nil;
								x = foundClassRange.location - 1
							}
						default:
							if( classNameEndLocation == nil )
							{
								classNameEndLocation = x
							}
					}
					
					if( classNameStartLocation != nil )
					{
						break
					}
				}
				
				if( classNameStartLocation != nil )
				{
					if classNameStr != ""	// We have a previous class that needs a closing bracket
					{
						destinationSwiftContents += "}\n"
					}
					classNameStr = fileContents.substringWithRange( NSRange( location: classNameStartLocation!, length: classNameEndLocation! - classNameStartLocation! + 1) )
					searchRange.location = foundClassRange.location + foundClassRange.length
					searchRange.length = fileContents.length - searchRange.location
					destinationHeaderContents += "typedef struct \(classNameStr) \(classNameStr);\n\nvoid \(classNameStr)_deinit( \(classNameStr)* _this );\n"
					destinationSourceContents += "extern \"C\" void \(classNameStr)_deinit( \(classNameStr)* _this )\n{\n\tdelete _this;\n}\n\n"
					destinationSwiftContents += "public class \(classNameStr)\n{\n\tlet cppinstance : COpaquePointer\n\n\tdeinit {\n\t\t\(classNameStr)_deinit(cppinstance)\n\t}\n\n"
					continue
				}
			}
			
			if( classNameStr == "" )
			{
				searchRange.location = foundRange.location + foundRange.length
				searchRange.length = fileContents.length - searchRange.location
				continue
			}
			
			// Scan backwards from the marker to get param list, function name and return type:
			var		closingParenLocation : Int?
			var		openingParenLocation : Int?
			var		funcNameEndLocation : Int?
			var		funcNameStartLocation : Int?
			var		returnTypeEndLocation : Int?
			var		returnTypeStartLocation : Int?
			
			for( var x = foundRange.location - 1; x > 0; x-- )
			{
				switch( fileContents.characterAtIndex(x) )
				{
					case 0x29:
						if( closingParenLocation == nil )
						{
							closingParenLocation = x	// +++ Handle nested parentheses.
						}
					case 0x28:
						if( closingParenLocation != nil )
						{
							openingParenLocation = x + 1	// +++ Handle nested parentheses.
						}
					case 0x20, 0x09, 0x0d, 0x0a:
						if( funcNameEndLocation != nil && funcNameStartLocation == nil )
						{
							funcNameStartLocation = x + 1
						}
						else if( returnTypeEndLocation != nil && returnTypeStartLocation == nil )
						{
							returnTypeStartLocation = x + 1
						}
					case 0x23:	// Hash sign? Prolly the preprocessor macros we use to hide our markers from C.
						x = -1;
					default:
						if( openingParenLocation != nil && funcNameEndLocation == nil )
						{
							funcNameEndLocation = x + 1
						}
						else if( funcNameStartLocation != nil && returnTypeEndLocation == nil )
						{
							returnTypeEndLocation = x
						}
						break
				}
				
				// If we have a full method declaration with params and return type, or
				//	it's an init/deinit and we have a method name, exit this loop:
				if( returnTypeStartLocation != nil || (isInit && funcNameStartLocation != nil) )
				{
					break
				}
			}
			
			if( returnTypeStartLocation != nil )
			{
				let	returnTypeStr = fileContents.substringWithRange( NSRange( location: returnTypeStartLocation!, length: returnTypeEndLocation! - returnTypeStartLocation! + 1) )
				let	funcNameStr = fileContents.substringWithRange( NSRange( location: funcNameStartLocation!, length: funcNameEndLocation! - funcNameStartLocation!) )
				let	paramListStr = fileContents.substringWithRange( NSRange( location: openingParenLocation!, length: closingParenLocation! - openingParenLocation!) )
				var isClass : Bool = false
				if( paramListStr != "" )
				{
					destinationHeaderContents += "\(returnTypeStr) \(classNameStr)_\(funcNameStr)( \(classNameStr)* _this, \(paramListStr));\n"
					destinationSourceContents += "extern \"C\" \(returnTypeStr) \(classNameStr)_\(funcNameStr)( \(classNameStr)* _this, \(paramListStr))\n{\n\treturn _this->\(funcNameStr)(\(callParamsFromDeclaration(paramListStr)));\n}\n\n"
					destinationSwiftContents += "\tpublic func \(funcNameStr)(\(swiftDeclaration(paramListStr))) -> \(cTypeToSwift(returnTypeStr,isClass:&isClass)) {\n\t\treturn \(classNameStr)_\(funcNameStr)(cppinstance, \(swiftCallParamsFromDeclaration(paramListStr)))\n\t}\n\n"
				}
				else
				{
					destinationHeaderContents += "\(returnTypeStr) \(classNameStr)_\(funcNameStr)( \(classNameStr)* _this );\n"
					destinationSourceContents += "extern \"C\" \(returnTypeStr) \(classNameStr)_\(funcNameStr)( \(classNameStr)* _this )\n{\n\treturn _this->\(funcNameStr)();\n}\n\n"
					destinationSwiftContents += "\tpublic func \(funcNameStr)() -> \(cTypeToSwift(returnTypeStr,isClass:&isClass)) {\n\t\treturn \(classNameStr)_\(funcNameStr)(cppinstance)\n\t}\n\n"
				}
			}
			else if( funcNameStartLocation != nil )	// Constructor
			{
				let	funcNameStr = fileContents.substringWithRange( NSRange( location: funcNameStartLocation!, length: funcNameEndLocation! - funcNameStartLocation!) )
				let	paramListStr = fileContents.substringWithRange( NSRange( location: openingParenLocation!, length: closingParenLocation! - openingParenLocation!) )
				if( funcNameStr == classNameStr )
				{
					if paramListStr == ""
					{
						destinationHeaderContents += "\(classNameStr)* \(classNameStr)_init( void );\n"
						destinationSourceContents += "extern \"C\" \(classNameStr)* \(classNameStr)_init( void )\n{\n\treturn new \(classNameStr);\n}\n\n"
						destinationSwiftContents += "\tpublic init() {\n\t\tcppinstance = \(classNameStr)_init()\n\t}\n\n"
					}
					else
					{
						destinationHeaderContents += "\(classNameStr)* \(classNameStr)_init(\(paramListStr));\n"
						destinationSourceContents += "extern \"C\" \(classNameStr)* \(classNameStr)_init(\(paramListStr))\n{\n\treturn new \(classNameStr)(\(callParamsFromDeclaration(paramListStr)));\n}\n\n"
						destinationSwiftContents += "\tpublic init(\(swiftDeclaration(paramListStr))) {\n\t\tcppinstance = \(classNameStr)_init(\(swiftCallParamsFromDeclaration(paramListStr)))\n\t}\n\n"
					}
				}
			}
			
			searchRange.location = foundRange.location + foundRange.length
			searchRange.length = fileLength - searchRange.location
		}
		
		if classNameStr != ""	// We has at least one class, so need to add a closing bracket
		{
			destinationSwiftContents += "}\n"
		}
		
		destinationHeaderContents += "\n#if __cplusplus\n}\n#endif /* __cplusplus */\n"
	}
	
	func writeOutFiles() throws
	{
		try destinationHeaderContents.writeToFile( destinationFile + ".h", atomically: true, encoding: NSUTF8StringEncoding )
		try destinationSourceContents.writeToFile( destinationFile + ".cpp", atomically: true, encoding: NSUTF8StringEncoding )
		try destinationSwiftContents.writeToFile( destinationFile + ".swift", atomically: true, encoding: NSUTF8StringEncoding )
	}
}

let inputArg = Process.arguments[1]
let outputArg = (Process.argc > 2) ? Process.arguments[2] : (withoutPathExtension(inputArg) + "_cp2s");
var	parser = cpptoswift( sourceFile: inputArg, destinationFile: outputArg )
do
{
	try parser.parse()
	try parser.writeOutFiles()
}
catch let error as NSError
{
	print( "Error: \(error.localizedDescription)" );
	exit(1)
}