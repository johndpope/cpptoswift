//
//  main.swift
//  cpptoswift
//
//  Created by Uli Kusterer on 18/10/15.
//  Copyright Â© 2015 Uli Kusterer. All rights reserved.
//

import Foundation

class cpptoswift
{
	let		sourceFile : String
	let		destinationFile : String
	var		destinationHeaderContents = ""
	var		destinationSourceContents = ""
	var		destinationSwiftContents = ""
	
	init( sourceFile srcFile : String, destinationFile dstFile : String )
	{
		sourceFile = srcFile
		destinationFile = dstFile
	}
	
	func callParamsFromDeclaration( paramListStr : NSString ) -> String
	{
		var	paramsWithoutTypes : [String] = []
		var	paramsWithTypes = paramListStr.componentsSeparatedByString(",")
		for( var x = 0; x < paramsWithTypes.count; x++ )
		{
			paramsWithoutTypes.append( paramsWithTypes[x].stringByTrimmingCharactersInSet(NSCharacterSet.whitespaceAndNewlineCharacterSet()).componentsSeparatedByCharactersInSet( NSCharacterSet.whitespaceAndNewlineCharacterSet() ).last! )
		}
		return NSArray(array:paramsWithoutTypes).componentsJoinedByString(",")
	}
	
	func parse() throws
	{
		destinationHeaderContents = "// This file was auto-generated by cpptoswift.\n// Do not edit this file, edit the original source file \(sourceFile)\n\n#if __cplusplus\nextern \"C\"\n{\n#endif /* __cplusplus */\n\n"
		destinationSourceContents = "// This file was auto-generated by cpptoswift.\n// Do not edit this file, edit the original source file \(sourceFile)\n\n#include \"\(destinationFile)\"\n\n\n"
		destinationSwiftContents = "// This file was auto-generated by cpptoswift.\n// Do not edit this file, edit the original source file \(sourceFile)\n\n"
		
		let	fileContents = try NSString(contentsOfFile: sourceFile, encoding: NSUTF8StringEncoding)
		
		var	classNameStr = ""
		let	fileLength = fileContents.length;
		var	searchRange = NSRange(location: 0, length: fileLength)
		while( true )
		{
			var	foundClassRange : NSRange = fileContents.rangeOfString( "CP2SCLASS", options: NSStringCompareOptions(), range: searchRange )
			let	foundMethodRange : NSRange = fileContents.rangeOfString( "CP2SMETHOD", options: NSStringCompareOptions(), range: searchRange )
			let	foundInitRange : NSRange = fileContents.rangeOfString( "CP2SINIT", options: NSStringCompareOptions(), range: searchRange )
			if foundMethodRange.location == NSNotFound && foundInitRange.location == NSNotFound && foundClassRange.location == NSNotFound
			{
				break;
			}
			
			let	foundRange = (foundMethodRange.location < foundInitRange.location) ? foundMethodRange : foundInitRange
			let	isInit = foundInitRange.location == foundRange.location
			
			if( foundClassRange.location != NSNotFound && foundClassRange.location < foundRange.location )
			{
				var		classNameStartLocation : Int?
				var		classNameEndLocation : Int?
				
				for( var x = foundClassRange.location - 1; x > 0; x-- )
				{
					switch( fileContents.characterAtIndex(x) )
					{
						case 0x20, 0x09, 0x0d, 0x0a:
							if( classNameEndLocation != nil && classNameStartLocation == nil )
							{
								classNameStartLocation = x + 1
							}
						case 0x23:	// Hash sign? Prolly the preprocessor macros we use to hide our markers from C.
							x = -1;
							var classSearchRange : NSRange = searchRange
							classSearchRange.location = foundClassRange.location + foundClassRange.length
							classSearchRange.length = fileLength - classSearchRange.location
							
							// Try to find the next class name declaration:
							foundClassRange = fileContents.rangeOfString( "CP2SCLASS", options: NSStringCompareOptions(), range: classSearchRange )
							if foundClassRange.location < foundRange.location
							{
								classNameStartLocation = nil;
								classNameEndLocation = nil;
								x = foundClassRange.location - 1
							}
						default:
							if( classNameEndLocation == nil )
							{
								classNameEndLocation = x
							}
					}
					
					if( classNameStartLocation != nil )
					{
						break
					}
				}
				
				if( classNameStartLocation != nil )
				{
					if classNameStr != ""	// We have a previous class that needs a closing bracket
					{
						destinationSwiftContents += "}\n"
					}
					classNameStr = fileContents.substringWithRange( NSRange( location: classNameStartLocation!, length: classNameEndLocation! - classNameStartLocation! + 1) )
					searchRange.location = foundClassRange.location + foundClassRange.length
					searchRange.length = fileContents.length - searchRange.location
					destinationHeaderContents += "void \(classNameStr)_deinit( struct \(classNameStr)* _this );\n"
					destinationSourceContents += "extern \"C\" void \(classNameStr)_deinit( struct \(classNameStr)* _this )\n{\n\tdelete _this;\n}\n\n"
					destinationSwiftContents += "class \(classNameStr)\n{\n\tlet cppinstance : OpaqueCPointer\n\n\tdeinit {\n\t\t\(classNameStr)_deinit(cppinstance)\n\t}\n\n"
					continue
				}
			}
			
			if( classNameStr == "" )
			{
				searchRange.location = foundRange.location + foundRange.length
				searchRange.length = fileContents.length - searchRange.location
				continue
			}
			
			// Scan backwards from the marker to get param list, function name and return type:
			var		closingParenLocation : Int?
			var		openingParenLocation : Int?
			var		funcNameEndLocation : Int?
			var		funcNameStartLocation : Int?
			var		returnTypeEndLocation : Int?
			var		returnTypeStartLocation : Int?
			
			for( var x = foundRange.location - 1; x > 0; x-- )
			{
				switch( fileContents.characterAtIndex(x) )
				{
					case 0x29:
						if( closingParenLocation == nil )
						{
							closingParenLocation = x	// +++ Handle nested parentheses.
						}
					case 0x28:
						if( closingParenLocation != nil )
						{
							openingParenLocation = x + 1	// +++ Handle nested parentheses.
						}
					case 0x20, 0x09, 0x0d, 0x0a:
						if( funcNameEndLocation != nil && funcNameStartLocation == nil )
						{
							funcNameStartLocation = x + 1
						}
						else if( returnTypeEndLocation != nil && returnTypeStartLocation == nil )
						{
							returnTypeStartLocation = x + 1
						}
					case 0x23:	// Hash sign? Prolly the preprocessor macros we use to hide our markers from C.
						x = -1;
					default:
						if( openingParenLocation != nil && funcNameEndLocation == nil )
						{
							funcNameEndLocation = x + 1
						}
						else if( funcNameStartLocation != nil && returnTypeEndLocation == nil )
						{
							returnTypeEndLocation = x
						}
						break
				}
				
				// If we have a full method declaration with params and return type, or
				//	it's an init/deinit and we have a method name, exit this loop:
				if( returnTypeStartLocation != nil || (isInit && funcNameStartLocation != nil) )
				{
					break
				}
			}
			
			if( returnTypeStartLocation != nil )
			{
				let	returnTypeStr = fileContents.substringWithRange( NSRange( location: returnTypeStartLocation!, length: returnTypeEndLocation! - returnTypeStartLocation! + 1) )
				let	funcNameStr = fileContents.substringWithRange( NSRange( location: funcNameStartLocation!, length: funcNameEndLocation! - funcNameStartLocation!) )
				let	paramListStr = fileContents.substringWithRange( NSRange( location: openingParenLocation!, length: closingParenLocation! - openingParenLocation!) )
				if( paramListStr != "" )
				{
					destinationHeaderContents += "\(returnTypeStr) \(classNameStr)_\(funcNameStr)( struct \(classNameStr)* _this, \(paramListStr));\n"
					destinationSourceContents += "extern \"C\" \(returnTypeStr) \(classNameStr)_\(funcNameStr)( struct \(classNameStr)* _this, \(paramListStr))\n{\n\treturn _this->\(funcNameStr)(\(callParamsFromDeclaration(paramListStr)));\n}\n\n"
					destinationSwiftContents += "\tfunc \(funcNameStr)(\(paramListStr)) -> \(returnTypeStr) {\n\t\treturn \(classNameStr)_\(funcNameStr)(cppinstance, \(callParamsFromDeclaration(paramListStr)))\n\t}\n\n"
				}
				else
				{
					destinationHeaderContents += "\(returnTypeStr) \(classNameStr)_\(funcNameStr)( struct \(classNameStr)* _this );\n"
					destinationSourceContents += "extern \"C\" \(returnTypeStr) \(classNameStr)_\(funcNameStr)( struct \(classNameStr)* _this )\n{\n\treturn _this->\(funcNameStr)();\n}\n\n"
					destinationSwiftContents += "\tfunc \(funcNameStr)(\(paramListStr)) -> \(returnTypeStr) {\n\t\treturn \(classNameStr)_\(funcNameStr)(cppinstance)\n\t}\n\n"
				}
			}
			else if( funcNameStartLocation != nil )	// Constructor
			{
				let	funcNameStr = fileContents.substringWithRange( NSRange( location: funcNameStartLocation!, length: funcNameEndLocation! - funcNameStartLocation!) )
				let	paramListStr = fileContents.substringWithRange( NSRange( location: openingParenLocation!, length: closingParenLocation! - openingParenLocation!) )
				if( funcNameStr == classNameStr )
				{
					if paramListStr == ""
					{
						destinationHeaderContents += "struct \(classNameStr)* \(classNameStr)_init( void );\n"
						destinationSourceContents += "extern \"C\" struct \(classNameStr)* \(classNameStr)_init( void )\n{\n\treturn new \(classNameStr);\n}\n\n"
						destinationSwiftContents += "\tfunc init() {\n\t\tcppinstance = \(classNameStr)_init()\n\t}\n\n"
					}
					else
					{
						destinationHeaderContents += "struct \(classNameStr)* \(classNameStr)_init(\(paramListStr));\n"
						destinationSourceContents += "extern \"C\" struct \(classNameStr)* \(classNameStr)_init(\(paramListStr))\n{\n\treturn new \(classNameStr)(\(callParamsFromDeclaration(paramListStr)));\n}\n\n"
						destinationSwiftContents += "\tfunc init(\(paramListStr)) {\n\t\tcppinstance = \(classNameStr)_init(\(callParamsFromDeclaration(paramListStr)))\n\t}\n\n"
					}
				}
			}
			
			searchRange.location = foundRange.location + foundRange.length
			searchRange.length = fileLength - searchRange.location
		}
		
		if classNameStr != ""	// We has at least one class, so need to add a closing bracket
		{
			destinationSwiftContents += "}\n"
		}
		
		destinationHeaderContents += "\n#if __cplusplus\n}\n#endif /* __cplusplus */\n"
	}
	
	func writeOutFiles() throws
	{
		try destinationHeaderContents.writeToFile( destinationFile + ".h", atomically: true, encoding: NSUTF8StringEncoding )
		try destinationSourceContents.writeToFile( destinationFile + ".cpp", atomically: true, encoding: NSUTF8StringEncoding )
		try destinationSwiftContents.writeToFile( destinationFile + ".swift", atomically: true, encoding: NSUTF8StringEncoding )
	}
}


var	parser = cpptoswift( sourceFile: Process.arguments[1], destinationFile: Process.arguments[2] )
do
{
	try parser.parse()
	try parser.writeOutFiles()
}
catch let error as NSError
{
	print( "Error: \(error.localizedDescription)" );
	exit(1)
}